// Code generated by "genpls:proxy"; DO NOT EDIT.
// github.com/WinPooh32/genpls

package parse

import (
	"errors"
	"go/types"
	io_1 "io"
	types_2 "parse/types"
)

// *ProxyI2 implements I2.
type ProxyI2[T any, U comparable, Q io_1.Reader] struct {
	v      I2[T, U, Q]
	logger interface{Log(string, ...any)}
}

func NewProxyI2[T any, U comparable, Q io_1.Reader](v I2[T, U, Q], logger interface{Log(string, ...any)}) (*ProxyI2[T, U, Q], error) {
	if v == nil {
		return nil, errors.New("v is nil")
	}
	if logger == nil {
		return nil, errors.New("logger is nil")
	}
	return &ProxyI2[T, U, Q]{
		v:      v,
		logger: logger,
	}, nil
}

func (p *ProxyI2[T, U, Q]) IMethod1() {
	p.logger.Log("Calling IMethod1", "arguments", )
	p.v.IMethod1()
	p.logger.Log("Calling IMethod1", "results")
}

func (p *ProxyI2[T, U, Q]) IMethod3(a int, b types_2.S1, c types_2.S2[string], d types_2.S2[*types.Package]) (types_2.S1, error) {
	p.logger.Log("Calling IMethod3", "arguments", a, b, c, d)
	r0, r1 := p.v.IMethod3(a, b, c, d)
	p.logger.Log("Calling IMethod3", "results", r0, r1)
	return r0, r1
}

func (p *ProxyI2[T, U, Q]) imethod2(t T) (u U) {
	p.logger.Log("Calling imethod2", "arguments", t)
	r0 := p.v.imethod2(t)
	p.logger.Log("Calling imethod2", "results", r0)
	return r0
}

// *ProxyI1 implements I1.
type ProxyI1 struct {
	v      I1
	logger interface{Log(string, ...any)}
}

func NewProxyI1(v I1, logger interface{Log(string, ...any)}) (*ProxyI1, error) {
	if v == nil {
		return nil, errors.New("v is nil")
	}
	if logger == nil {
		return nil, errors.New("logger is nil")
	}
	return &ProxyI1{
		v:      v,
		logger: logger,
	}, nil
}

func (p *ProxyI1) IMethod1() {
	p.logger.Log("Calling IMethod1", "arguments", )
	p.v.IMethod1()
	p.logger.Log("Calling IMethod1", "results")
}

func (p *ProxyI1) imethod2() {
	p.logger.Log("Calling imethod2", "arguments", )
	p.v.imethod2()
	p.logger.Log("Calling imethod2", "results")
}

// *ProxyAliasIface implements AliasIface.
type ProxyAliasIface struct {
	v      AliasIface
	logger interface{Log(string, ...any)}
}

func NewProxyAliasIface(v AliasIface, logger interface{Log(string, ...any)}) (*ProxyAliasIface, error) {
	if v == nil {
		return nil, errors.New("v is nil")
	}
	if logger == nil {
		return nil, errors.New("logger is nil")
	}
	return &ProxyAliasIface{
		v:      v,
		logger: logger,
	}, nil
}

func (p *ProxyAliasIface) IMethod1() {
	p.logger.Log("Calling IMethod1", "arguments", )
	p.v.IMethod1()
	p.logger.Log("Calling IMethod1", "results")
}

func (p *ProxyAliasIface) imethod2() {
	p.logger.Log("Calling imethod2", "arguments", )
	p.v.imethod2()
	p.logger.Log("Calling imethod2", "results")
}

