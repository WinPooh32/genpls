// Code generated by "genpls:mock"; DO NOT EDIT.

package parse

import (
	"go/types"
	io_1 "io"
	types_2 "parse/types"
)

// *MockI2 implements I2.
type MockI2[T any, U comparable, Q io_1.Reader] struct {
	IMethod1Func func ()
	IMethod3Func func (a int, b types_2.S1, c types_2.S2[string], d types_2.S2[*types.Package]) (types_2.S1, error)
	imethod2Func func (t T) (u U)

	Calls struct{
		IMethod1 []struct{ 
			 
		}
		IMethod3 []struct{ 
			a int
			b types_2.S1
			c types_2.S2[string]
			d types_2.S2[*types.Package] 
		}
		imethod2 []struct{ 
			t T 
		}
	}
}

func (mock *MockI2[T, U, Q]) IMethod1() {
	if mock.IMethod1Func == nil {
		panic("nil method IMethod1 is called!")
	}

	callInfo := struct{ 
			
	} {  }

	mock.Calls.IMethod1 = append(mock.Calls.IMethod1, callInfo)

	mock.IMethod1Func()
}

func (mock *MockI2[T, U, Q]) IMethod3(a int, b types_2.S1, c types_2.S2[string], d types_2.S2[*types.Package]) (types_2.S1, error) {
	if mock.IMethod3Func == nil {
		panic("nil method IMethod3 is called!")
	}

	callInfo := struct{ 
			a int
			b types_2.S1
			c types_2.S2[string]
			d types_2.S2[*types.Package]
	} { a, b, c, d }

	mock.Calls.IMethod3 = append(mock.Calls.IMethod3, callInfo)

	return mock.IMethod3Func(a, b, c, d)
}

func (mock *MockI2[T, U, Q]) imethod2(t T) (u U) {
	if mock.imethod2Func == nil {
		panic("nil method imethod2 is called!")
	}

	callInfo := struct{ 
			t T
	} { t }

	mock.Calls.imethod2 = append(mock.Calls.imethod2, callInfo)

	return mock.imethod2Func(t)
}

